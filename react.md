### React 组件最佳实践

1. useMemo useCallback 要真的考虑清楚是否有用的必要性  如何他们以来的deps本身就是变化频繁的 可能就没有必要了  他们会带来额外的空间消耗
2. useMemo或者useCallback依赖的deps数组为空时 就说明我们希望存储一个值 这个值在组件re-render时不会变化的  这种情况可以直接替换成useRef 或者踢到组件外面

### useEffect

1. 无论useEffect的依赖是什么 在函数组件initial的时候，第一次渲染的时候，都必须执行： 这就是代表了之前的didmount，其次每次re-render的时候依赖项有变化都会执行，
2. 每当函数组件执行的时候 这包括首次初始化渲染执行和之后的状态改变导致的更新执行  记住函数都是整体重新执行了的。所以每次useEffect对应的callback函数都是重新生成的了  那么在本次函数执行时 callback的作用域链上对应的函数的状态都是最新的
3. 一般建议把不依赖state和props的函数移动到函数组件外面。
4. **Effect拿到的总是定义它的那次渲染中的props和state**

5. ***组件内的每一个函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获定义它们的那次渲染中的props和state。***
6. useEffect中的清除逻辑都会被延迟到下一次渲染完成后执行，状态更新，函数重新执行，useEffect执行重新，useEffect对应回调函数重新定义(这包括里面返回的清除函数也是重新定义，他们都拿到了本次渲
染的最新的状态)， render执行， dom更新渲染完成，**这时执行上一次effect中的清除函数的逻辑，这个清除函数中保留的事上次的旧状态的**  执行完后 再执行本地新状态的对应的useEffect对应的回调函数>的逻辑。

7. 你可以从依赖中去除`dispatch`, `setState`, 和`useRef`包裹的值因为React会确保它们是静态的。不过你设置了它们作为依赖也没什么问题。他们在整个react生命周期内是保持不变的
8. 当状态比较复杂的时候 或者想从useEffect中剔除依赖的时候 可以考虑使用useReducer
9. 实际上，在组件内定义的函数每一次渲染都在变。
10.### React 组件最佳实践 

1. useMemo useCallback 要真的考虑清楚是否有用的必要性  如何他们以来的deps本身就是变化频繁的 可能就没有必要了  他们会带来额外的空间消耗 
2. useMemo或者useCallback依赖的deps数组为空时 就说明我们希望存储一个值 这个值在组件re-render时不会变化的  这种情况可以直接替换成useRef 或者踢到组件外面

### useEffect

1. 无论useEffect的依赖是什么 在函数组件initial的时候，第一次渲染的时候，都必须执行： 这就是代表了之前的didmount，其次每次re-render的时候依赖项有变化都会执行，
2. 每当函数组件执行的时候 这包括首次初始化渲染执行和之后的状态改变导致的更新执行  记住函数都是整体重新执行了的。所以每次useEffect对应的callback函数都是重新生成的了  那么在本次函数执行时 callback的作用域链上对应的函数的状态都是最新的 
3. 一般建议把不依赖state和props的函数移动到函数组件外面。
4. **Effect拿到的总是定义它的那次渲染中的props和state**

5. ***组件内的每一个函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获定义它们的那次渲染中的props和state。***
6. useEffect中的清除逻辑都会被延迟到下一次渲染完成后执行，状态更新，函数重新执行，useEffect执行重新，useEffect对应回调函数重新定义(这包括里面返回的清除函数也是重新定义，他们都拿到了本次渲染的最新的状态)， render执行， dom更新渲染完成，**这时执行上一次effect中的清除函数的逻辑，这个清除函数中保留的事上次的旧状态的**  执行完后 再执行本地新状态的对应的useEffect对应的回调函数的逻辑。

7. 你可以从依赖中去除`dispatch`, `setState`, 和`useRef`包裹的值因为React会确保它们是静态的。不过你设置了它们作为依赖也没什么问题。他们在整个react生命周期内是保持不变的
8. 当状态比较复杂的时候 或者想从useEffect中剔除依赖的时候 可以考虑使用useReducer 
9. 实际上，在组件内定义的函数每一次渲染都在变。
10. 
